<!DOCTYPE html>
<html lang="en">
<!-- [Previous head and style sections remain exactly the same] -->
<body>
  <div id="loading-screen"></div>
  <div id="ar-scene">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; filterMinCF:0.0001; filterBeta:0.001"
      embedded
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      <a-assets>
        <video
          id="vid1"
          src="assets/asset.mp4"
          preload="auto"
          loop
          crossorigin="anonymous"
          playsinline
          webkit-playsinline
        ></video>
        <video
          id="vid2"
          src="assets/asset2.mp4"
          preload="auto"
          loop
          crossorigin="anonymous"
          playsinline
          webkit-playsinline
        ></video>
      </a-assets>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-plane
          id="video-plane-0"
          position="0 0 0"
          rotation="0 0 0"
          material="transparent: true"
          video-material="video: #vid2; targetIndex: 0"
          visible="false"
        ></a-plane>
      </a-entity>

      <a-entity mindar-image-target="targetIndex: 1">
        <a-plane
          id="video-plane-1"
          position="0 0 0"
          rotation="0 0 0"
          material="transparent: true"
          video-material="video: #vid1; targetIndex: 1"
          visible="false"
        ></a-plane>
      </a-entity>
    </a-scene>
  </div>
  <div id="playButton" class="play-button"></div>

  <script>
    AFRAME.registerComponent('video-material', {
      schema: {
        video: { type: 'selector' },
        targetIndex: { type: 'number' }
      },

      init: function () {
        const mesh = this.el.getObject3D('mesh');
        const video = this.data.video;
        const targetIndex = this.data.targetIndex;

        // Get the MindAR component to access target information
        const sceneEl = document.querySelector('a-scene');
        const mindARComponent = sceneEl.components['mindar-image'];

        video.addEventListener('loadedmetadata', () => {
          // Get target dimensions
          const target = mindARComponent.controller.processor.dimensions[targetIndex];
          const targetRatio = target.width / target.height;
          const isTargetVertical = target.height > target.width;
          
          console.log(`Target ${targetIndex} dimensions:`, target.width, target.height, 'Ratio:', targetRatio);
          
          // Set base size depending on target orientation
          let width, height;
          if (isTargetVertical) {
            // Vertical target
            width = 1;
            height = width * (target.height / target.width);
          } else {
            // Horizontal target
            height = 1;
            width = height * (target.width / target.height);
          }

          // Set the plane dimensions
          this.el.setAttribute('width', width);
          this.el.setAttribute('height', height);
          
          console.log(`Set dimensions for video ${targetIndex}:`, width, height);
        });

        // [Rest of the shader code remains exactly the same]
        const vertexShader = `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const fragmentShader = `
          varying vec2 vUv;
          uniform sampler2D videoTexture;
          
          void main() {
            vec4 color = texture2D(videoTexture, vUv);
            
            // Calculate distance from edges
            float dx = min(vUv.x, 1.0 - vUv.x);
            float dy = min(vUv.y, 1.0 - vUv.y);
            float edgeDistance = min(dx, dy);
            
            // Create soft edges
            float fadeWidth = 0.15;
            float opacity = smoothstep(0.0, fadeWidth, edgeDistance);
            
            // Apply overall transparency
            float globalOpacity = 0.9;
            
            gl_FragColor = vec4(color.rgb, color.a * opacity * globalOpacity);
          }
        `;

        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

        const material = new THREE.ShaderMaterial({
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          uniforms: {
            videoTexture: { value: videoTexture }
          },
          transparent: true
        });

        mesh.material = material;
      }
    });

    // [Rest of the code remains exactly the same]
  </script>
</body>
</html>
