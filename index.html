<!DOCTYPE html>
<html lang="en">
<!-- [Previous head section remains the same] -->

<body>
  <div id="loading-screen"></div>
  <div id="ar-scene">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; filterMinCF:0.0001; filterBeta:0.001"
      embedded
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      <a-assets>
        <video
          id="vid1"
          src="assets/asset.mp4"
          preload="auto"
          loop
          crossorigin="anonymous"
          playsinline
          webkit-playsinline
        ></video>
        <video
          id="vid2"
          src="assets/asset2.mp4"
          preload="auto"
          loop
          crossorigin="anonymous"
          playsinline
          webkit-playsinline
        ></video>
      </a-assets>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-plane
          width="1"
          height="1.5"
          position="0 0 0"
          rotation="0 0 0"
          material="transparent: true"
          video-material="video: #vid2"
          dynamic-video-size="video: #vid2; targetIndex: 0"
          visible="false"
        ></a-plane>
      </a-entity>

      <a-entity mindar-image-target="targetIndex: 1">
        <a-plane
          width="1.5"
          height="1"
          position="0 0 0"
          rotation="0 0 0"
          material="transparent: true"
          video-material="video: #vid1"
          dynamic-video-size="video: #vid1; targetIndex: 1"
          visible="false"
        ></a-plane>
      </a-entity>
    </a-scene>
  </div>
  <div id="playButton" class="play-button"></div>

  <script>
    // [Previous video-material component remains the same]

    // Add new component for dynamic video sizing
    AFRAME.registerComponent('dynamic-video-size', {
      schema: {
        video: { type: 'selector' },
        targetIndex: { type: 'number' }
      },

      init: function() {
        this.video = this.data.video;
        this.targetIndex = this.data.targetIndex;
        this.controller = null;
        this.processVideo = this.processVideo.bind(this);

        // Wait for video metadata to load
        if (this.video.readyState >= 2) {
          this.processVideo();
        } else {
          this.video.addEventListener('loadedmetadata', this.processVideo);
        }

        // Get the MindAR controller
        const sceneEl = document.querySelector('a-scene');
        sceneEl.addEventListener('arReady', () => {
          const mindARComponent = sceneEl.components['mindar-image'];
          this.controller = mindARComponent.controller;
        });

        // Update size on each frame
        this.el.sceneEl.addEventListener('renderstart', () => {
          this.updateSize();
        });
      },

      processVideo: function() {
        // Store original video dimensions
        this.videoRatio = this.video.videoWidth / this.video.videoHeight;
        console.log(`Video ${this.targetIndex} ratio: ${this.videoRatio}`);
      },

      updateSize: function() {
        if (!this.controller || !this.videoRatio) return;

        // Get the target's projected size in the camera view
        const projectionMatrix = this.controller.getProjectionMatrix();
        const targetMatrix = this.controller.getTargetWorldMatrix(this.targetIndex);
        
        if (!targetMatrix) return;

        // Calculate the projected size of the target
        const position = new THREE.Vector3();
        position.setFromMatrixPosition(targetMatrix);
        
        // Get distance from camera to target
        const distance = position.length();
        
        // Calculate the visible size of the target at the current distance
        const fov = 2 * Math.atan(1 / projectionMatrix.elements[5]);
        const visibleHeight = 2 * Math.tan(fov / 2) * distance;
        const visibleWidth = visibleHeight * (window.innerWidth / window.innerHeight);

        // Get target dimensions from MindAR
        const targetDimensions = this.controller.getTargetDimensions(this.targetIndex);
        if (!targetDimensions) return;

        // Calculate scale factors
        const targetRatio = targetDimensions.width / targetDimensions.height;
        let width, height;

        if (this.videoRatio > targetRatio) {
          // Video is wider than target
          width = targetDimensions.width;
          height = width / this.videoRatio;
        } else {
          // Video is taller than target
          height = targetDimensions.height;
          width = height * this.videoRatio;
        }

        // Apply the new dimensions
        this.el.setAttribute('width', width);
        this.el.setAttribute('height', height);
      },

      remove: function() {
        this.video.removeEventListener('loadedmetadata', this.processVideo);
      }
    });

    // [Previous DOMContentLoaded event handler remains the same]
  </script>
</body>
</html>
